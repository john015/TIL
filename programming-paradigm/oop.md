# Object Oriented Programming

객체 지향 프로그래밍이란 캡슐화, 상속, 다형성 세 가지 개념을 사용하여 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

## 클래스

- 추상화를 거쳐 데이터의 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것

## 객체 지향 프로그래밍의 장단점

### 장점

#### 코드 재사용이 용이

- 이미 작성된 코드를 가져와서 사용할 수 있고 상속을 통해 확장해서 사용할 수 있음.

#### 유지보수가 쉬움

- 수정해야 할 부분이 클래스 내부에 변수혹은 메소드로 있기 때문에 해당 부분만 수정하면 됨.

### 단점

#### overhead가 많이 발생함

- 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다

#### 객체가 상태를 갖고있음

- 객체내에 변수가 존재하여 동일한 입력에도 변수 값에 따라 다른 값을 반환할 수도 있다.(side effect가 있음)
- 이 변수때문에 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시키고 테스팅을 하기 어렵게만든다.

## OOP의 특징

### 추상화

- 객체들에서 공통의 속성이나 기능을 묶어 상위 클래스를 생성하는것(ex, 뱀, 오리, 닭 이라는 객체들이 있을때 이들을 동물 또는 생물 클래스로 묶을 수 있다)

### 상속

- 상위 객체의 필드와 메소드를 하위 객체에게 물려줘 하위 객체가 상위 객체의 기능을 사용할 수 있도록 하는 것.

### 다형성

- 어떤 하나의 객체가 여러 개의 형태를 갖는 것 오버로딩이나 오버라이딩을 통해 다형성을 구현할 수 있다.
- overloading: 같은 이름의 함수를 매개변수의 개수나 타입에 따라서 다르게 사용하는 것.
- overriding: 부모 클래스의 메소드를 자식 클래스에서 똑같은 이름, 같은 반환 값, 같은 인자로 재 정의 하는 것.

### 캡슐화

- 비슷한 역할을 하는 필드와 메소드들을 하나로 묶고, 구현 내용을 외부에 감춰 외부 객체에서 객체 내부의 구조를 알지 못하고 객체가 노출한 필드와 메소드만 이용 가능하게 하는것.

#### 캡슐화를 위한 두 개의 규칙

##### Tell Don't ask

- 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라는 규칙.

```java

public class Customer {
  private Wallet wallet;
  public Wallet getWallet(){
    return wallet;
  }
}

```

필드를 private로 클래스 내부에 숨기고, 메소드를 통해서만 필드에 접근가능

##### 데미테르 법칙

- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출

## 객체 지향적 설계 원칙(SOLID원칙)

### SRP(Single Responsibility Principle): 단일 책임 원칙

- 클래스는 단 하나의 actor(시스템이 동일한 방식으로 변경되기를 원하는 사용자 집단)에 대한 책임을 가져야 한다
- 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
- SRP를 안 지킬 경우, 서로 다른 액터가 의존하는 코드들이 너무 가까이 있기 때문에 잦은 컨플릭트와 다른 도메인 서비스에서의 예기치 못한 사이드 이펙트가 발생할 수 있다.

#### 해결 방법

- 어떤 한 데이터가 여러 이유로 사용되면, 데이터와 메서드를 분리해서, `somethingData` 같은 클래스를 만든 뒤 서브 클래스들이 상위 클래스의 필드를 공유하고 서브 클래스들은 서로의 존재를 모르게 변경한다.
- 위 방법대로 하면 개발자가 서브 클래스들을 다 인스턴스화 하고 추적해야 하는 문제가 발생할 수 있다. 그런 경우 퍼사드 패턴을 이용해, 퍼사드 객체에서 서브 클래스들의 인스턴스를 생성하고 고수준의 인터페이스를 제공해줘서 인스턴스들을 캡슐화 할 수 있다.

### OCP(Open-Closed Principle): 개방-폐쇄 원칙

- 소프트웨어 개체는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- 다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 기존 개체를 변경해서는 안 된다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.

### LSP(Liskov Substitution Principle): 리스코프 치환 원칙

- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

### ISP(Interface Segregation Principle): 인터페이스 분리 원칙

- 클라이언트(기능을 사용하는 클래스)는 사용하지 않는 인터페이스에 의존하면 안된다.
- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리되어야 한다.
- 클래스에 자신이 사용하지 않는 인터페이스는 구현되지 말아야한다.

### DIP(Dependency Inversion Principle): 의존 역전 원칙

- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
- 저수준 모듈은 고수준 모듈이 정의한 추상 타입에 의존해야 한다.
